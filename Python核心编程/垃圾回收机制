垃圾回收
1.小整数对象池
整数在程序中的使用非常广泛，python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间
整数[-5,257)这些整数对象是提前建立好的，不会被垃圾回收的，在一个python的课程中，所有位于这个范围的整数使用的都是同一个对象
常驻内存，提高程序使用效率

2.大整数对象池
每一个大整数，均创建一个新对象

3.intern机制
只要是相同的字符串都共用同一块的内存地址，但是这个字符串里面要有空格等，那么就是单独使用一块内存地址

GC 垃圾回收
高级语言都使用了自动垃圾回收机制
1.引用计数是python中主要的垃圾回收机制：
python解释器中有一个ob_refcut这个对象，记录引用次数
但是计数器解决不了循环引用这种问题
2.Ruby和python的垃圾回收机制
标记清除机制  Ruby先申请一大片内存，等到所有内存都满了，再去回收，但是python是用一块申请一块
Ruby的回收凡是指向的变量标记1，没有指向的标记0，这样回收机制去回收时，是1的就保留，是就回收重新组成一块内存空间使用
python的隔代清除是辅助的垃圾回收机制
如果在内存中使用一组链表来追踪生成的对象，这是第一代链，首先在链上，经过引用计数机制，发生了循环调用无法解决的问题时，会给0代链上所有的计数减1
如果为0就出去，否则保留生成一代链，过一段时间在对一代链减1，为0出去，生成2代链，一共就三代，0代链清除最为频繁
在往1代链上挪动的时候，不仅会对0代链进行减1操作，同时会检查0代链上有没有循环引用的情况，如果有，会接着减1
import gc
gc.get_threshold()
返回值 (700,10,10)
返回三个阈值，分别对应了隔代清除垃圾回收机制的三个阈值
当新创建对象减去销毁对象大于700时，就对0代链进行清除，当0代链清除10次之后就对1代链进行清除，同时会清除一次0代链，当1代链清除10次之后，会对2代链进行一次清除
同时会对0、1代链进行一次清除
gc.get_count()
当前的值得情况，是否达到阈值

导致引用计数加1：
1.创建对象
2.把对象给另一个对象赋值  b=a
3.给函数传参
4.生成一个列表，把对象存到列表里面去

导致引用计数减1：
1.del
2.对象的别名赋予了一个新的对象
3.调用函数结束，减1
4.从列表中删除

使用gc.collect()手动对垃圾进行回收
使用gc.garbage 查看之前回收的垃圾

但是gc也是有bug的，如果你重写了__del__(),没有调用系统默认del方法是有问题的

内建属性
__init__  构建初始化函数
__new__   生成实例所需属性
__class__  实力所在的类
__str__   实例字符串表示  可读性
__repr__  实例字符串表示  准确性
__del__   删除实例
__dict__  实例自定义属性
__doc__  类文档，子类不继承
__getattribute__  属性访问拦截器，这个内建属性很有用，它既完成对属性的访问，又给属性的访问添加了新功能，对访问属性进行一些限制
__bases__  类的所有父类构成元素

内建属性：
只要是变量名，无论是函数名，还是变量名，都是指向一块内存空间
对象中并没有函数，对象先通过属性构建了函数，在将函数返回回来调用




















